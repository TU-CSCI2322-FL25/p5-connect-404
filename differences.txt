diff --git a/InputOutput.hs b/InputOutput.hs
deleted file mode 100644
index 57f9c1c..0000000
--- a/InputOutput.hs
+++ /dev/null
@@ -1,49 +0,0 @@
-module InputOutput where
-import Connect
-
---story 12: readGame function, Y\nYYYRRR\nYYRYYY\n... -> (Board, Color)
-readGame :: String -> GameState
-readGame str = (stringToBoard str, strToColor (head str))
-
-stringToBoard :: String -> Board
-stringToBoard str = [[strToPiece piece | piece <- col]| col <- lst]
-    where 
-        lst = tail $ lines str
-
-strToColor :: Char -> Color 
-strToColor 'Y' = Yellow
-strToColor 'R' = Red
-
-strToPiece :: Char -> Piece 
-strToPiece 'Y' = Full Yellow
-strToPiece 'R' = Full Red
-strToPiece 'E' = Empty
-
---story 13: showGame function, (Board,Color)
-showGame :: GameState -> String 
-showGame (board,color) = colorToStr color : "\n" ++ unlines [[pieceToStr piece | piece <- col ]|col <- board]  -- This is the part we need to fix! 
-
-colorToStr :: Color -> Char
-colorToStr Yellow = 'Y'
-colorToStr Red = 'R'
-
-pieceToStr :: Piece -> Char
-pieceToStr (Full Yellow) = 'Y'
-pieceToStr (Full Red) = 'R'
-pieceToStr Empty = 'E'
-
---story 14: IO functions 
--- main takes file? uses readGame to turn into a GameState then uses BestMove and prints answer
-main = do
-    putStrLn "Enter File Name"
-    fileName <- getLine 
-    contents <- readFile fileName
-    let 
-        game = readGame contents
-        move = undefined :: Move --bestMove game
-    print (move)
-
-    
-
-
-
diff --git a/Connect.hs b/connect.hs
similarity index 62%
rename from Connect.hs
rename to connect.hs
index 9d33f1d..b10aeb0 100644
--- a/Connect.hs
+++ b/connect.hs
@@ -1,13 +1,10 @@
-module Connect where
 import Data.List
-import Data.Maybe
-import Control.Monad (when)
 
 type GameState = (Board, Color) 
 type Move = Int 
 type Board = [Column] 
 data Piece = Empty | Full Color deriving (Show, Eq)
-data Winner = Won Color | Tie deriving (Show, Eq) 
+data Winner = Won Color | Ongoing Color | Tie deriving (Show, Eq) 
 type Column = [Piece] 
 data Color = Red | Yellow deriving (Show, Eq)
 
@@ -15,46 +12,18 @@ data Color = Red | Yellow deriving (Show, Eq)
 
 --story 2: find the winner
 --SHOULD JUST CHECK BOTH PLAYERS
-gameWinner :: GameState -> Maybe Winner
-gameWinner (board, player) 
-    | checkWin board Yellow  = Just (Won Yellow)
-    | checkWin board Red     = Just (Won Red)
-    | isFull board           = Just Tie
-    | otherwise              = Nothing
+gameWinner :: GameState -> Winner
+gameWinner (board, player)
+    | isFull board                              = Tie 
+    | checkWin board  && (player == Red)        = Won Yellow
+    | checkWin board  && (player == Yellow)     = Won Red
 
-{- Problems with current gameWinner 
-It still depends on player, which makes your result wrong depending on whose turn it is.
 
-Example of the bug:
-
-Yellow just won
-
-But player == Red
-→ your code incorrectly says Red won Yellow’s victory.
-
-Correct Version: gameWinner :: GameState -> Maybe Winner
-gameWinner (board, _) 
-    | checkWin board Red    = Just (Won Red)
-    | checkWin board Yellow = Just (Won Yellow)
-    | isFull board          = Just Tie
-    | otherwise             = Nothing
-
-Checks both players independently
-Never relies on turn order
-Returns Nothing for ongoing games
-Story 8 is training  for minimax recursion (Story 9).
-
-Minimax needs:
-    a function that says “this state is terminal, here is the winner”
-    OR returns Nothing if you must continue recursing
-
-
--}
 
 
 --SHOULD RETURN A BOOL!! 
-checkWin :: Board -> Player -> Bool --could be Won or Ongoing
-checkWin board player = checkAllColumns board player || checkRowsAndDiagonals board player
+checkWin :: Board -> Bool --could be Won or Ongoing
+checkWin board = checkAllColumns board Red || checkAllColumns board Yellow || checkRowsAndDiagonals board Red || checkRowsAndDiagonals board Yellow
  {-    | checkAllColumns board player || checkRowsAndDiagonals board player   = Won player
     | otherwise                                                            = Ongoing player -}
     
@@ -92,6 +61,12 @@ isFull :: Board -> Bool --head of all columns are full
 isFull board = all (/= Empty) [ head column | column <- board]
 -- head (reverse column) --> for if 1st element of col is bottom
 
+legalMoves :: GameState -> [Move]
+legalMoves gs@(board,color) = [fst x | x <- makeLookupList board, Empty `elem` snd x]
+
+makeLookupList :: Board -> [(Int, Column)]
+makeLookupList board = zip [0..6] board
+
 --Story 3 compute the result of a legal move
 
 updateGame :: GameState -> Move -> GameState
@@ -125,10 +100,11 @@ updateColumn (x:xs) color = x : updateColumn xs color -}
 --updateColumn --> Fogarty said to update board from the bottom 
 --POSSIBLE ERROR CHECK: what if the column is already full?
 updateColumn :: Column -> Color -> Column 
-updateColumn (Empty:Empty:rest) color = Empty:(updateColumn (Empty:rest)) color
-updateColumn (Empty:rest)       color =  (piece) :rest
-    where
-        piece = if color == Red then Full Red else Full Yellow
+updateColumn [x] color = [Full color]
+updateColumn (x:y:rest) color
+    | y == Full Red  || y == Full Yellow  = Full color:y:rest
+    | otherwise                           = x:updateColumn (y:rest) color
+
 --
 
 --updateColumn (E)
@@ -163,90 +139,16 @@ pieceToString (Full Yellow) = "Yellow "
 transposeBoard :: Board -> [[Piece]]
 transposeBoard board = if(checkValidBoard board) then foldr (zipWith (:)) (replicate 6 []) board else error "bad board"
 
+
+
+
 --for prettyprint you have to do putStrLn (prettyPrint oneFullBoard) for example for it to work)
 
 --story 6
 checkValidBoard :: Board -> Bool
 checkValidBoard board = length [x | x <- board, length x == 6] == 7
 
-isValidMove :: Move -> GameState -> Bool
-isValidMove n game = n `elem` legalMoves game 
-
-
---story9branch
-whoWillWin :: GameState -> Winner
-whoWillWin gs@(board,color) = case gameWinner gs of
-    Nothing -> chooseMove listOfFutureGame color
-    Just x  -> x
-    where
-         listOfFutureGame = [updateGame gs x | x <- legalMoves gs] 
-
-
-chooseMove :: [GameState] -> Color -> Winner
-chooseMove futures color =  if Won color `elem` futureWins 
-                            then Won color 
-                            else if Tie `elem` futureWins 
-                            then Tie 
-                            else Won (opponentColor color)
-                            where
-                                futureWins = [whoWillWin x | x <- futures]
-
-
---story 10
-bestMove :: GameState -> Move
-bestMove game@(board,color) = case filterForWin (Won color) of
-    [x] -> fst x
-    (x:y:xs) -> fst y
-    [] -> case filterForWin Tie of
-        [x] -> fst x
-        (x:y:xs) -> fst y
-        [] -> case filterForWin (Won (opponentColor color)) of 
-            [] -> error "i dont even know how you did this??? seriously text me if you get this error - 210 847 8314"
-            [x] -> fst x
-            (x:y:xs) -> fst y
-    where
-        lookUpList = [(x,whoWillWin (updateGame game x)) | x <- legalMoves game]
-        filterForWin win = filter(\x -> snd x == win) lookUpList
-
-
-
 
-----------------------------TESTS----------------------------
---these are variables tha make it a lot easier to right boards
-y = Full Yellow
-r = Full Red
-e = Empty
---this is a full board with no winners
---FullBoardNoWinners = 
-
-
---this is a board that results in a tie 
-tieBoard = [
-    [e, r, r, y, y, r],   
-    [e, y, r, y, r, y],   
-    [e, r, y, r, y, r],   
-    [e, r, y, r, y, r],   
-    [e, r, y, y, y, r],   
-    [e, y, r, y, r, y],   
-    [e, r, r, y, r, y]]
-
-redBoard = [
-    [e, r, y, r, y, r],   
-    [e, y, r, y, r, y],   
-    [e, r, y, r, y, r],   
-    [e, r, y, r, y, r],   
-    [e, r, y, y, y, r],   
-    [e, y, r, y, r, y],   
-    [e, r, r, y, r, y]]
-
-yellowBoard = [
-    [e, r, r, y, r, r],   
-    [y, y, r, y, r, y],   
-    [y, r, y, r, y, r],   
-    [r, r, y, r, y, r],   
-    [e, r, y, y, y, r],   
-    [e, y, r, y, r, y],   
-    [e, r, r, y, r, y]]
 
 
 ----------------------------TESTS----------------------------
@@ -292,7 +194,7 @@ emptyBoard = replicate 7 emptyColumn
 
 --testBoard :: GameState
 --testBoard = ([[Empty, Empty, Empty ,Empty, Empty, Full Yellow],[Empty, Empty, Full Red, Full Red, Full Red, Full Red],[Empty, Empty, Empty ,Empty, Empty, Full Yellow],[Empty, Empty, Empty, Empty, Empty, Empty],[Empty, Empty, Empty, Empty, Empty, Empty],[Empty, Empty, Empty, Empty, Empty, Empty],[Empty, Empty, Empty ,Empty, Empty, Full Yellow]], Yellow)
-testWorkVerticalWin = gameWinner testBoard --expected: won red
+testWorkVerticalWin = gameWinner testBoard --expected: WOn red
     where 
         testBoard = ([[Empty, Empty, Empty ,Empty, Empty, Full Yellow],[Empty, Empty, Full Red, Full Red, Full Red, Full Red],[Empty, Empty, Empty ,Empty, Empty, Full Yellow],[Empty, Empty, Empty, Empty, Empty, Empty],[Empty, Empty, Empty, Empty, Empty, Empty],[Empty, Empty, Empty, Empty, Empty, Empty],[Empty, Empty, Empty ,Empty, Empty, Full Yellow]], Yellow)
 
@@ -304,8 +206,6 @@ testpleaseWorkDiagonalWin = gameWinner testBoard --expected: won yellow
     where
         testBoard = ([[Empty, Empty, Empty, Empty, Empty, Full Red],[Empty, Full Yellow, Full Red, Full Red, Full Yellow, Full Red],[Empty, Empty, Full Yellow, Full Yellow, Full Yellow, Full Red],[Empty, Empty, Full Yellow, Full Yellow, Full Red, Full Yellow],[Empty, Empty, Empty, Full Red, Full Yellow, Full Red],[Empty, Empty, Empty, Empty, Empty, Empty, Empty],[Empty, Empty, Empty, Empty, Empty, Empty, Empty]], Red)
 
-testTieWin = gameWinner testBoard
-    where
-        testBoard = ([[Full Yellow, Full Yellow, Full Yellow, Full Red, Full Red, Full Red],[Full Yellow, Full Yellow, Full Red, Full Yellow, Full Yellow, Full Yellow],[Full Red, Full Yellow, Full Yellow, Full Red, Full Yellow, Full Yellow],[Full Yellow, Full Red, Full Red, Full Red, Full Yellow, Full Red],[Full Red, Full Yellow, Full Red, Full Yellow, Full Red, Full Red],[Full Red, Full Red, Full Yellow, Full Yellow, Full Red, Full Yellow]],Yellow)
+
 gameStart :: GameState
 gameStart = (emptyBoard, Red)
diff --git a/story_11_files/early_game.txt b/story_11_files/early_game.txt
deleted file mode 100644
index 3913e56..0000000
--- a/story_11_files/early_game.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-R
-EEEEER
-EEEEEE
-EEEEEY
-EEEEEE
-EEEEEE
-EEEEEE
-EEEEEE
\ No newline at end of file
diff --git a/story_11_files/finished_game.txt b/story_11_files/finished_game.txt
deleted file mode 100644
index 1e2cbbb..0000000
--- a/story_11_files/finished_game.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-Y
-YYYRRR
-YYRYYY
-RYYRYY
-YRRRYR
-RYRRRY
-RYRYRR
-RRYYRY
\ No newline at end of file
diff --git a/story_11_files/four_from_endgame_A.txt b/story_11_files/four_from_endgame_A.txt
deleted file mode 100644
index 36681f5..0000000
--- a/story_11_files/four_from_endgame_A.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-Y
-EEEEEE
-EEEEER
-EERYYR
-EEYRRY
-EEEEEE
-EEEEEE
-EEEEEY
\ No newline at end of file
diff --git a/story_11_files/simple_one_move_from_winning.txt b/story_11_files/simple_one_move_from_winning.txt
deleted file mode 100644
index 43fd823..0000000
--- a/story_11_files/simple_one_move_from_winning.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-R
-EEEYYR
-EEEEYR
-EEEEER
-EEEEEE
-EEEEEE
-EEEEEE
-EEEEEE
\ No newline at end of file
diff --git a/story_11_files/three_from_endgame_A.txt b/story_11_files/three_from_endgame_A.txt
deleted file mode 100644
index bf3460e..0000000
--- a/story_11_files/three_from_endgame_A.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-R
-EEEEEE
-EEEEEE
-EEEEYY
-EEYRRR
-EEEERY
-EEEEEE
-EEEEER
diff --git a/story_11_files/tie.txt b/story_11_files/tie.txt
deleted file mode 100644
index 1e2cbbb..0000000
--- a/story_11_files/tie.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-Y
-YYYRRR
-YYRYYY
-RYYRYY
-YRRRYR
-RYRRRY
-RYRYRR
-RRYYRY
\ No newline at end of file
